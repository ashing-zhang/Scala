1.字段/变量的定义Scala中使用 **var/val 变量/不变量名称：类型** 的方式进行定义。其中var和val的区别在于，var是变量，以后的值还可以改变，val的值只能在声明的时候赋值，但是val不是常量，只能说是不变量或者只读变量。

2.类型推断：

```
能让scala自动理解省略的类型。
```

3.尽可能才用val的不变量。

4.scala没有基本数据类型的概念。

5.scala表达式

```
不使用return语句，最后一个表达式即返回值。
```

6.scala块表达式

```
--块中最后一个表达式的值就是块的值。
--表达式语句既可以用分号分隔，也可以用换行来分隔。
```

7.to和until

```
to:包含尾部
until：不包含尾部
```

8.用idea maven创建scala工程

```
1.创建maven工程
2.依赖文件要添加对scala-library的依赖
3.创建名为"scala"的文件夹
4.右击"scala"选择"Mark Directory as"->"Sources Root"
5.若右击"scala"文件夹没有"Scala class"显示，则选择"File"->"Project Structure"->"Global Libraries"，点击"-", 把scala-sdk除去，然后再点击"+",把scala-sdk添加进来，此时就能创建"Scala Class"
```

9.breakable结构（具体用break跳出循环）可以跳出循环

10.lazy：懒加载

11.空参函数

```
--如果一个函数在定义的时候没有参数，在调用的时候，可以省略掉（）
--如果在定义一个空参函数的时候，省略了（），那么在调用的时候就必须也省略掉（）
```

12.单行函数

```
必须要使用“=”将函数体和函数签名连接
```

13.定长数组

```
--数据的构建
  ---使用new关键字创建一个定长数组
  eg. val array = new Array[Int](30) //长度为30的整数数组，所有元素初始化为0
  ---直接使用Array创建并初始化一个数组
  eg.val sArr = Array("Hello","World") //长度为2的Array[String]类型是推断出来的，所以就不需要new
--数据的赋值
  数组名（index） = 值
  sArr（0） = "Hello Tom",使用（）而不是[]访问元素
--获取数组元素
  数组名（index）
  val result = sArr（1）
```

14.mkString

```
将集合中每一个元素拼接成一个字符串
```

15.drop

```
删除集合中的元素，并返回，原集合不变
```

16.构造器

```
--scala中和类名相同的方法并不是构造器。
--scala的其中一个构造器（主构造器）就在类名后面，因为是无参的，所以默认省略的（），也就是参数列表。
```

17.主构造器和辅助构造器

```
--scala的构造器有两种，一种在类名后面定义的，一种在类中使用this关键字来定义
  第一种构造器，被称之为scala类的主构造器
  第二种构造器，被称之为scala类的辅助构造器
--scala中的辅助构造器的第一句话，必须要调用本类的主构造器或者其他辅助构造器
```

18.object

```
--object中定义的成员都是类似于java中的静态成员，也就是直接可以通过类名.调用，无须创建对象。
--object作用：
	1.给scala类提供程序运行入口，静态的main函数
	2.给scala类也能够提供静态成员---scala类的伴生对象来实现
```

19.伴生对象

```
--把同一个源文件中相同名称的object结构称之为class结构的伴生对象，反过来，把这个class结构称为object结构的伴生类
--伴生类/伴生对象的特点：
	1.伴生对象可以访问伴生类中非私有和私有成员
	2.通常重写apply方法来生成伴生类对象
		apply方法特点：返回值类型是本类引用；参数列表对应伴生类的构造器参数列表

```

20.extends（继承/扩展）

```
--子类覆盖父类的方法时，必须要添加关键字override进行修饰，否则认为子类重新写了一个同名方法，造成方法同名，报错（除非是抽象方法）
--子类想要访问父类的成员的时候，就需要使用super关键字
```

21.超类的构造过程

```
1.scala中在继承体系中，构造子类时，先构造父类
2.子类在构造器中想要传递参数到父类的构造器中，只能通过主构造器，因为辅助构造器的第一句话，只能调用本类的主构造器，或者其他辅助构造器
```

22.匿名子类

```
对于接口，抽象类只被调用一次的情况，同时父类中的（抽象）方法相对较简单
```

23.抽象类

```
1.scala类中子类复写父类的抽象成员的时候，可以省略override关键字
2.scala类中的抽象成员，可以省略abstract关键字
```

24.抽象字段

```
所有抽象字段，只有字段的声明，没有初始化的字段
```

25.trait

```
1.trait在一定程度上，可以看做java中的接口interface---如果一个trait特质中的所有的方法都是抽象的，那么就可以将其视作为java中的一个接口。
2.扩展特质trait和扩展父类使用的是相同的关键字extends，扩展多个trait时使用with关键字来分割。
3.如果既继承一个类，又扩展一个特质，书写的顺序是继承类优先，其次再with特质。
```

26.sealed

```
scala中对于一个类的子类都是已知的，可以使用一个sealed关键字来进行修饰，表示该类是密封，刚好和枚举的含义相契合
```

27.函数可以作为值，传递给另外一个变量，或者另外一个函数。语法特点：必须要在函数后面加上空格或者下划线。

28.匿名函数：将匿名函数复制给另外一个变量或者函数，来被调用

```
（params） => returnType //匿名函数的定义
（params） => {body} //匿名函数的实现
```

